//! All binary files generated by measureme have a simple file header that
//! consists of a 4 byte file magic string and a 4 byte little-endian version
//! number.

use std::convert::TryInto;
use crate::GenericError;

pub const CURRENT_FILE_FORMAT_VERSION: u32 = 6;
pub const FILE_MAGIC_EVENT_STREAM: &[u8; 4] = b"MMES";
pub const FILE_MAGIC_STRINGTABLE_DATA: &[u8; 4] = b"MMSD";
pub const FILE_MAGIC_STRINGTABLE_INDEX: &[u8; 4] = b"MMSI";
pub const FILE_MAGIC_PAGED_FORMAT: &[u8; 4] = b"MMPF";


/// The size of the file header in bytes. Note that functions in this module
/// rely on this size to be `8`.
pub const FILE_HEADER_SIZE: usize = 8;

pub fn write_file_header(s: &mut dyn std::io::Write, file_magic: &[u8; 4]) -> Result<(), GenericError> {
    // The implementation here relies on FILE_HEADER_SIZE to have the value 8.
    // Let's make sure this assumption cannot be violated without being noticed.
    assert_eq!(FILE_HEADER_SIZE, 8);

    s.write_all(file_magic).map_err(Box::new)?;
    s.write_all(&CURRENT_FILE_FORMAT_VERSION.to_le_bytes()).map_err(Box::new)?;

    Ok(())
}

pub fn read_file_header(bytes: &[u8], expected_magic: &[u8; 4]) -> Result<u32, GenericError> {
    // The implementation here relies on FILE_HEADER_SIZE to have the value 8.
    // Let's make sure this assumption cannot be violated without being noticed.
    assert_eq!(FILE_HEADER_SIZE, 8);

    let actual_magic = &bytes[0..4];

    if actual_magic != expected_magic {
        // FIXME: The error message should mention the file path in order to be
        //        more useful.
        let msg = format!(
            "Unexpected file magic `{:?}`. Expected `{:?}`",
            actual_magic, expected_magic,
        );

        return Err(From::from(msg));
    }

    Ok(u32::from_le_bytes(bytes[4..8].try_into().unwrap()))
}

pub fn strip_file_header(data: &[u8]) -> &[u8] {
    &data[FILE_HEADER_SIZE..]
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::serialization::{ByteVecSink, SerializationSink};

    #[test]
    fn roundtrip() {
        let data_sink = ByteVecSink::new();

        write_file_header(&mut data_sink.as_std_write(), FILE_MAGIC_EVENT_STREAM).unwrap();

        let data = data_sink.into_bytes();

        assert_eq!(
            read_file_header(&data, FILE_MAGIC_EVENT_STREAM).unwrap(),
            CURRENT_FILE_FORMAT_VERSION
        );
    }

    #[test]
    fn invalid_magic() {
        let data_sink = ByteVecSink::new();
        write_file_header(&mut data_sink.as_std_write(), FILE_MAGIC_STRINGTABLE_DATA).unwrap();
        let mut data = data_sink.into_bytes();

        // Invalidate the filemagic
        data[2] = 0;
        assert!(read_file_header(&data, FILE_MAGIC_STRINGTABLE_DATA).is_err());
    }

    #[test]
    fn other_version() {
        let data_sink = ByteVecSink::new();

        write_file_header(&mut data_sink.as_std_write(), FILE_MAGIC_STRINGTABLE_INDEX).unwrap();

        let mut data = data_sink.into_bytes();

        // Change version
        data[4] = 0xFF;
        data[5] = 0xFF;
        data[6] = 0xFF;
        data[7] = 0xFF;
        assert_eq!(
            read_file_header(&data, FILE_MAGIC_STRINGTABLE_INDEX).unwrap(),
            0xFFFF_FFFF
        );
    }
}
